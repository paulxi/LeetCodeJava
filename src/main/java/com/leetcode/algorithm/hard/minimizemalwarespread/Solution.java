package com.leetcode.algorithm.hard.minimizemalwarespread;

import java.util.Arrays;

class Solution {
  public int minMalwareSpread(int[][] graph, int[] initial) {
    // 1. color each component
    int n = graph.length;
    int[] colors = new int[n];
    Arrays.fill(colors, -1);

    int color = 0;
    for (int i = 0; i < n; i++) {
      if (colors[i] == -1) {
        dfs(graph, colors, i, color++);
      }
    }

    // 2. Size of each color
    int[] size = new int[color];
    for (int c: colors) {
      size[c]++;
    }

    // 3. Find unique colors
    int[] colorCount = new int[color];
    for (int node: initial) {
      colorCount[colors[node]]++;
    }

    // 4. Find answer
    int ans = Integer.MAX_VALUE;
    for (int node: initial) {
      int c = colors[node];
      if (colorCount[c] == 1) {
        if (ans == Integer.MAX_VALUE) {
          ans = node;
        } else if (size[c] > size[colors[ans]]) {
          ans = node;
        } else if (size[c] == size[colors[ans]] && node < ans) {
          ans = node;
        }
      }
    }

    if (ans == Integer.MAX_VALUE) {
      for (int node: initial) {
        ans = Math.min(ans, node);
      }
    }

    return ans;
  }

  private void dfs(int[][] graph, int[] colors, int node, int color) {
    colors[node] = color;
    for (int nei = 0; nei < graph.length; nei++) {
      if (graph[node][nei] == 1 && colors[nei] == -1) {
        dfs(graph, colors, nei, color);
      }
    }
  }
}
