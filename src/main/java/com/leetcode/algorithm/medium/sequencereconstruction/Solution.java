package com.leetcode.algorithm.medium.sequencereconstruction;

import java.util.*;

class Solution {
  public boolean sequenceReconstruction(int[] org, List<List<Integer>> seqs) {
    Map<Integer, Set<Integer>> map = new HashMap<>();
    Map<Integer, Integer> indegree = new HashMap<>();

    for (List<Integer> seq: seqs) {
      if (seq.size() == 1) {
        if (!map.containsKey(seq.get(0))) {
          map.put(seq.get(0), new HashSet<>());
          indegree.put(seq.get(0), 0);
        }
      } else {
        for (int i = 0; i < seq.size() - 1; i++) {
          if (!map.containsKey(seq.get(0))) {
            map.put(seq.get(0), new HashSet<>());
            indegree.put(seq.get(0), 0);
          }

          if (!map.containsKey(seq.get(i + 1))) {
            map.put(seq.get(i + 1), new HashSet<>());
            indegree.put(seq.get(i + 1), 0);
          }

          if (map.get(seq.get(i)).add(seq.get(i + 1))) {
            indegree.put(seq.get(i + 1), indegree.get(seq.get(i + 1)) + 1);
          }
        }
      }
    }

    if (map.size() != org.length) {
      return false;
    }

    Queue<Integer> queue = new LinkedList<>();
    for (Map.Entry<Integer, Integer> entry: indegree.entrySet()) {
      if (entry.getValue() == 0) {
        queue.offer(entry.getKey());
      }
    }

    int index = 0;
    while (!queue.isEmpty()) {
      int size = queue.size();
      if (size > 1) {
        return false;
      }

      int curr = queue.poll();
      if (index == org.length || curr != org[index]) {
        return false;
      }
      index++;

      for (int next: map.get(curr)) {
        indegree.put(next, indegree.get(next) - 1);
        if (indegree.get(next) == 0) {
          queue.offer(next);
        }
      }
    }

    return index == org.length;
  }
}
